ë¬¸ì„œì •ë³´ : 2024.03.05.~03.06. ì‘ì„±, ì‘ì„±ì [@SAgiKPJH](https://github.com/SAgiKPJH)

- ìš”ì•½ - ë‹¹ì¥ ì‚¬ìš© ê°€ëŠ¥í•œì§€ ë¶„ì„í•œ ê²°ê³¼ : [LanguageExt ì‹¬í™”](https://github.com/SagiK-Repository/Learn_C_Sharp_LangeageExt/issues/1)

# Language.Ext

# ğŸšŒLanguage.Ext?

- C#ì„ í™•ì¥í•˜ì—¬ `í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°`ì„ ì§€ì›í•˜ê¸° ìœ„í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ì…ë‹ˆë‹¤.
  - í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ 'ë² ì´ìŠ¤ í´ë˜ìŠ¤ ë¼ì´ë¸ŒëŸ¬ë¦¬'ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
- GitHub ì‚¬ì´íŠ¸ : https://github.com/louthy/language-ext

### ğŸ¤–ì‘ì„±ì Paul Louthì€ ë§í•œë‹¤.

> Paul Louth : C# í”„ë¡œê·¸ë˜ë°ì„ í›¨ì‹  ë” ì•ˆì •ì ì´ê³ , ì½”ë“œ ì‘ì„±ì‹œ ì—”ì§€ë‹ˆì–´ì˜ ê´€ì„±ì´ ëª…ë ¹í˜•ì´ ì•„ë‹Œ ì„ ì–¸í˜•ì´ê³  ê¸°ëŠ¥ì ì´ê¸¸ ë°”ëë‹ˆë‹¤.

<br>

# ğŸ›»í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°

- í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°(FP : Functional Programming)

> ìë£Œ ì²˜ë¦¬ë¥¼ ìˆ˜í•™ì  í•¨ìˆ˜ì˜ ê³„ì‚°ìœ¼ë¡œ ì·¨ê¸‰í•˜ê³  ìƒíƒœì™€ ê°€ë³€ ë°ì´í„°ë¥¼ ë©€ë¦¬í•˜ëŠ” í”„ë¡œê·¸ë˜ë° íŒ¨ëŸ¬ë‹¤ì„ì˜ í•˜ë‚˜ì…ë‹ˆë‹¤.
> - Wikipedia

## íŠ¹ì§•

- ìˆ˜í•™ì  í•¨ìˆ˜ ê³„ì‚°ì„ ê¸°ë°˜ìœ¼ë¡œ í•©ë‹ˆë‹¤.
- `ìƒíƒœì™€ ê°€ë³€ ë°ì´í„°ë¥¼ í”¼í•˜ëŠ” ë°©ì‹`ì…ë‹ˆë‹¤.
- **ìˆœìˆ˜í•¨ìˆ˜**
  - `í•¨ìˆ˜ì˜ ê²°ê³¼ê°’ì€ ì˜¤ì§ ì…ë ¥ê°’ì—ë§Œ ì˜ì¡´`í•©ë‹ˆë‹¤.
  - `ì™¸ë¶€ í™˜ê²½ì— ì˜í–¥ì„ ë°›ì§€ ì•ŠìŠµë‹ˆë‹¤.`
  - ìˆœìˆ˜ í•¨ìˆ˜ëŠ” ì°¸ì¡°ì— ëŒ€í•´ íˆ¬ëª…í•˜ë©°, í”„ë¡œê·¸ë¨ì˜ ì˜ˆì¸¡ì„±ê³¼ íˆ¬ëª…ì„±ì„ ë†’ì…ë‹ˆë‹¤.
- **ê³ ì°¨ í•¨ìˆ˜**
  - í•¨ìˆ˜ë¥¼ ë‹¤ë£¨ëŠ” í•¨ìˆ˜
  - í•¨ìˆ˜ë¥¼ ì¸ìˆ˜ë¡œ ë°›ê±°ë‚˜ ê²°ê³¼ë¡œ ë°˜í™˜ ê°€ëŠ¥
  - í•¨ìˆ˜ì˜ ì¶”ìƒí™”ì™€ ì¬ì‚¬ìš©ì„±ì„ ì¦ê°€
- **ì§€ì—° í‰ê°€**
  - í•¨ìˆ˜ì˜ ì¸ìˆ˜ë¥¼ í•„ìš”í•  ë•Œê¹Œì§€ í‰ê°€í•˜ì§€ ì•Šê³ , `ì‹¤ì œ ì‚¬ìš©í•˜ëŠ” ì‚¬ì ì— í‰ê°€`
  - ë”°ë¼ì„œ ë¬´í•œí•œ ë°ì´í„° êµ¬ì¡°ë¥¼ ë‹¤ë£° ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- **íƒ€ì… ì‹œìŠ¤í…œ**
  - í•¨ìˆ˜í˜• ì–¸ì–´ëŠ” ëŒ€ë¶€ë¶„ ì •ì  íƒ€ì… ê²€ì‚¬ë¥¼ ì§€ì›
  - íƒ€ì… ì¶”ë¡ ì„ í†µí•´ íƒ€ì…ì„ ìë™ìœ¼ë¡œ ê²°ì •í•  ìˆ˜ ìˆë‹¤.
  - í”„ë¡œê·¸ë¨ì˜ ì •í™•ì„±ê³¼ ì•ˆì •ì„±ì„ ë³´ì¥

<br><br>

# ğŸšœLanguage.Ext ì²« ì¸ì‚¬

- Nuget Packageì— LanguageExt.Coreë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
- ë‹¤ìŒ usingì„ í•„ìˆ˜ë¡œ ì„ ì–¸í•´ì¤ë‹ˆë‹¤.
```cs
using LanguageExt;
using static LanguageExt.Prelude;
```
- ë‹¤ìŒ ì½”ë“œë¥¼ ì‘ì„±í•´ í™•ì¸í•©ë‹ˆë‹¤.
```cs
Option<int> x = Some(123);
Option<int> y = None;

Seq<int> items = Seq(1,2,3,4,5);
List<int> items = List(1,2,3,4,5);
HashMap<int, string> dict = HashMap((1, "Hello"), (2, "World"));
Map<int, string> dict = Map((1, "Hello"), (2, "World"));

var x
 = map(opt, v => v * 2);
// or
var x = opt.Map(v => v * 2);
```

<br><br>

# ğŸš’Language.Ext íŠ¹ì§•

1. í•¨ìˆ˜í˜• íš¨ê³¼ì™€ IO
   - í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì—ì„œ ì¤‘ìš”í•œ ê°œë…ì¸ íš¨ê³¼(effect)ì™€ ì…ì¶œë ¥(IO)ì„ ë‹¤ë£¹ë‹ˆë‹¤.
   - `Aff<A>` `Eff<A>` `Aff<RT,A>` `Eff<RT, A>` `Pipes`
2. ì›ìì„± ë™ì‹œì„±ê³¼ ì»¬ë ‰ì…˜
   - ì›ìì„±(atomicity)ì„ ë³´ì¥í•˜ëŠ” ë™ì‹œì„±(concurrency) ê¸°ëŠ¥ê³¼ ì»¬ë ‰ì…˜ì„ ì œê³µí•©ë‹ˆë‹¤.
   - `Atom<A>` `Ref<A>` `AtomHashMap<K, V>` `AtopSeq<A>` `VectorClock<A>` `VersionVector<A>` `VersionHashMap <ConflictV, K, V>`
3. ë¶ˆë³€ ì»¬ë ‰ì…˜
   - ë¶ˆë³€ì„±(immutable)ì„ ê°€ì§„ ì»¬ë ‰ì…˜ì„ ì œê³µí•©ë‹ˆë‹¤.
   - `Arr<A>` `Seq<A>` `Lst<A>` `Map<K, V>` `Map<OrdK, K, V>` `HashMap<K, V>` `HashMap<EqK, K, V>` `Set<A>` `Set<OrdA, A>` `HashSet<A>` `HashSet<EqA, A>` `Que<A>` `Stck<A>`
4. ì˜µì…”ë„ ë° ëŒ€ì²´ ê°’ ëª¨ë‚˜ë“œ
   - ì˜µì…”ë„(optional)ê³¼ ëŒ€ì²´ ê°’(alternative value)ì„ ë‹¤ë£¨ëŠ” ëª¨ë‚˜ë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤.
   - `Option<A>` `OptionAsync<A>` `OptionUnsafe<A>` `Either<L, R>` `EitherUnsae<L, R>` `EitherAsync<L, R>`
   - `Try<A>` `TryAsync<A>` `TryOption<A>` `TryOptionAsync<A>` `Validation<FAIL, SUCCESS>` `Validation<MonoidFail, FAIL, SUCCESS>`
5. ìƒíƒœ ê´€ë¦¬ ëª¨ë‚˜ë“œ
   - ìƒíƒœ(state)ë¥¼ ê´€ë¦¬í•˜ëŠ” ëª¨ë‚˜ë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤.
   - `Reader<E, A>` `Writer<MonoidW, W, T>` `State<S, A>` `RWS<R, W, S, A>`
6. íŒŒì„œ ì½¤ë¹„ë„¤ì´í„°
   - íŒŒì„œ(parser)ë¥¼ ì¡°í•©í•˜ëŠ” ì½¤ë¹„ë„¤ì´í„°(combinator)ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
   - `Parser<A>` `Parser<I, O>`
7. íƒ€ì… ë³„ì¹­
   - ìƒˆë¡œìš´ íƒ€ì…ì„ ë§Œë“œëŠ” íƒ€ì… ë³„ì¹­(type aliasing) ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
   - `NewType<SELF, A, PRED>` `NumType<SELF, NUM, A, PRED>` `FloatType<SELF, FLOATING, A, PRED>`
8. ì½”ë“œ ìƒì„±
   - ë ˆì½”ë“œ, ìœ ë‹ˆì˜¨, í”„ë¦¬ ëª¨ë‚˜ë“œ, ë Œì¦ˆ ë“±ì„ ìœ„í•œ ì½”ë“œ ìƒì„± ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
   - `Records` `Unions` `Free monads` `Reader` `RWS` `With` `WithLens` `Lens<A, B>` `Record<A>`
9. ê¸°íƒ€
   - Pretty : `Doc<A>`
   - Differencing : `Patch<EqA, A>`
10. C# í™•ì¥

<br><br>

# ğŸš‘LanguageExt ì‹¤ ì‚¬ìš©

## Linqì™€ì˜ ìœ ì‚¬ì„±
- ë‹¤ìŒ í‚¤ì›Œë“œëŠ” Linqì™€ ë™ì¼í•©ë‹ˆë‹¤.
- `Sum`, `Count`, `Bind`, `Exists`, `Filter`, `Fold`, `ForAll`, `Iter`, `Map`, `Lift/LiftUnsafe`, `Select`, `SelectMany`, `Where`

<br>

## ê°„í¸í•œ record types ìƒì„±
- C#ì—ì„œ Recordì˜ `Equals, GetHashCode, IEquatable<A>, IComparer<A>, ì—°ì‚°ì ==, !=, <, <=, >=, >`ë¥¼ êµ¬í˜„í•˜ëŠ” ê²ƒì€ ì‰½ì§€ ì•ŠìŠµë‹ˆë‹¤.
- ì´ë¥¼ ì‰½ê²Œ í•´ì¤ë‹ˆë‹¤.
- ê¸°ì¡´
  ```cs
    public class User
    {
        public readonly Guid Id;
        public readonly string Name;
        public readonly int Age;

        public User(Guid id, string name, int age)
        {
            Id = id;
            Name = name;
            Age = age;
        }
    }
  ```
- LaunguageExt
  ```cs
    public class UserRecord : Record<UserRecord>
    {
        public readonly Guid Id;
        public readonly string Name;
        public readonly int Age;

        public UserRecord(Guid id, string name, int age)
        {
            Id = id;
            Name = name;
            Age = age;
        }
    }
  ```
- UnitTest
  ```cs
    [Fact]
    public void record_types()
    {
        var spongeGuid = Guid.NewGuid();

        // Use Original C#
        var spongeBob = new User(spongeGuid, "Spongebob", 40);
        var spongeBob2 = new User(spongeGuid, "Spongebob", 40);

        Assert.False(spongeBob.Equals(spongeBob2));

        // Use immutable records available in Language-ext
        var spongeBobRecord = new UserRecord(spongeGuid, "Spongebob", 40);
        var spongeBobRecord2 = new UserRecord(spongeGuid, "Spongebob", 40);

        Assert.True(spongeBobRecord.Equals(spongeBobRecord2));
    }
  ```

<br>

## ì‰¬ìš´ Parse

- C#ì˜ `TryParse`ë¥¼ ëŒ€ì²´í•©ë‹ˆë‹¤.
  ```cs
  int res = parseInt("123").IfNone(0);
  // or
  int res = ifNone(parseInt("123"), 0);
  // or
  int res = parseInt("123").Match(
    Some : x => x * 2,
    None : () => 0
  );
  // or
  int res = match( parseInt("123"),
                   Some : x => x * 2,
                   None : () => 0);
  ```

<br>

## Option í™œìš©í•œ null ì œì–´

- Optionì€ F#ì—ë„ ì¡´ì¬í•©ë‹ˆë‹¤. ê¸°ëŠ¥ì  ì–¸ì–´ì—ì„œëŠ” null ê°’ì„ í—ˆìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
  ```cs
  Option<int> aValue = 2;
  aValue.Map(x => x + 3); // Some(5)
  
  Option<int> none = None;
  none.Map(x => x + 3); // None
  
  //Left -> Some, Right -> None
  aValue.Match(x => x + 3, () => 0); // 5
  none.Match(x => x + 3, () => 0); // 0
  
  // Returns the Some case 'as is' -> 2 and 1 in the None case
  int value = aValue.IfNone(1);
  int noneValue = none.IfNone(42); // 42
  
  int value = aValue.Match(
    Some : x => x + 3,
    None : () => 0
  );

  int x = optional
    .Some( v  => v + 3 )
    .None( () => 0 );
  ```
- Match
  - ê¸°ì¡´ Typeì™€ ë§¤ì¹­
- Map
  1. ê¸°ì¡´ Typeì™€ ë§¤ì¹­
  2. ë˜ëŠ” ë…¼ë¦¬ë¥¼ ìˆ˜í–‰
  - ì‹¬í™”
    - Optionì´ Noneì´ë©´ Linqê°€ í˜¸ì¶œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
    - Optionì€ ifë¥¼ ëŒ€ì²´í•˜ê¸°ì—, if obj == nullì™€ ê°™ì€ ì˜ë¯¸ë¡œ êµ¬ì„±ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

<br>

## List Or Fucnctors

- List ë”°ìœ„ë¥¼ ë§¤í•‘ ê°€ëŠ¥í•©ë‹ˆë‹¤.
  ```cs
  new int[] { 2, 4, 6 }.Map(x => x + 3); // 5,7,9
  new List<int> { 2, 4, 6 }.Map(x => x + 3); // 5,7,9
  //Prefer use List (Immutable list)
  List(2, 4, 6).Map(x => x + 3); // 5,7,9

  List(2, 4, 6)
    .Map(x => Add5(x)) // 7, 9, 11
    .Map(x => Add3(x)) // 10, 12, 14
    .Map(x => Add2(x)) // 12, 14, 16
    .Map(x => Add5(x));// 17, 19, 21
  ```

<br>

## í•¨ìˆ˜ êµ¬ì„± (Compose)

- í•¨ìˆ˜ì—ì„œ mapì„ í†µí•´ í•¨ìˆ˜ í•©ì„± ìˆ˜í–‰
  ```cs
  static Func<int, int> Add2 = x => x + 2;
  static Func<int, int> Add3 = x => x + 3;

  static int Add5(int x) => Add2.Compose(Add3)(x);
  ```

<br>

## ë¬¶ìŒ (Bind)

- MonadsëŠ” ì…ë ¥í•œ ë˜í•‘í•œ ê°’(Option<double>) ê·¸ëŒ€ë¡œ ê°™ì€ Typeë¡œ ë‚˜ì˜µë‹ˆë‹¤.
- Bindë¡œ ë¬¶ì–´ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
  ```cs
  static Option<double> Half(double x)
      => x % 2 == 0 ? x / 2 : Option<double>.None;
  
  [Fact]
  public void bind_monad()
  {
      Option<double>.Some(3).Bind(x => Half(x));// None
      Option<double>.Some(4).Bind(x => Half(x));// Some(2)
  }
  
  [Fact]
  public void chain_bind_monad()
  {
      Option<double>.Some(20)
          .Bind(x => Half(x))// Some(10)
          .Bind(x => Half(x))// Some(5)
          .Bind(x => Half(x));// None
  }
  ```

<br>

## Try

- ë” ì‰½ê²Œ Try ì˜ˆì™¸ì²˜ë¦¬ ê°€ëŠ¥í•©ë‹ˆë‹¤.
- ë”ì´ìƒ Try Catch í•„ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
- ì •ë§ ì½ê¸° ì‰¬ìš´ í˜•ì‹ìœ¼ë¡œ íŒŒì´í”„ ë¼ì¸ì„ ì„¤ëª… ê°€ëŠ¥í•©ë‹ˆë‹¤.
  ```cs
  public void file_monad_example()
  {
      GetLine()
          .Bind(ReadFile)
          .Bind(PrintStrln)
          .Match(success => Console.WriteLine("SUCCESS"), // Try Success
                  failure => Console.WriteLine("FAILURE")); // Catch
  }
  
  static Try<string> GetLine()
  {
      Console.Write("File:");
      return Try(() => Console.ReadLine());
  }
  
  static Try<string> ReadFile(string filePath) => Try(() => File.ReadAllText(filePath));
  
  static Try<bool> PrintStrln(string line)
  {
      Console.WriteLine(line);
      return Try(true);
  }
  ```

<br>

## Memoization - ìºì‹±

- MemoizationëŠ” ì¼ì¢…ì˜ ìºì‹±ì…ë‹ˆë‹¤.
- íŠ¹ì • ê¸°ëŠ¥ì„ ë©”ëª¨í•˜ë©´, íŠ¹ì • ì…ë ¥ì— ëŒ€í•´ ë©”ëª¨ í•œ ë’¤, ë™ì¼í•œ ì…ë ¥ì´ ë“¤ì–´ì˜¤ë©´ ë©”ëª¨í•œ ë‚´ìš©(ìºì‹±)ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
  ```cs
  static Func<string, string> GenerateGuidForUser = user => user + ":" + Guid.NewGuid();
  static Func<string, string> GenerateGuidForUserMemoized = memo(GenerateGuidForUser);
  
  [Fact]
  public void memoization_example()
  {
      GenerateGuidForUserMemoized("spongebob");// spongebob:e431b439-3397-4016-8d2e-e4629e51bf62
      GenerateGuidForUserMemoized("buzz");// buzz:50c4ee49-7d74-472c-acc8-fd0f593fccfe
      GenerateGuidForUserMemoized("spongebob");// spongebob:e431b439-3397-4016-8d2e-e4629e51bf62
  }
  ```

<br>

## ê¸°ëŠ¥ ë¶€ë¶„ ì ìš©

- ì¼ë¶€ ì¸ìˆ˜ë¥¼ ë¶€ë¶„ ì„¤ì •í•˜ì—¬ ìƒˆ ê¸°ëŠ¥ì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
  ```cs
  static Func<int, int, int> Multiply = (a, b) => a * b;
  static Func<int, int> TwoTimes = par(Multiply, 2);
  
  [Fact]
  public void partial_app_example()
  {
      Multiply(3, 4); // 12
      TwoTimes(9); // 18
  }
  ```

<br>

## Either (ì–´ëŠ í•˜ë‚˜)

- ì„±ê³µì‚¬ë¡€(ì˜¤ë¥¸ìª½)ì™€ ì‹¤íŒ¨ì‚¬ë¡€(ì™¼ìª½) ë‘ ê°€ì§€ ìœ í˜•ì˜ ê°’ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
  ```cs
  public static Either<Exception, string> GetHtml(string url)
  {
      var httpClient = new HttpClient(new HttpClientHandler());
      try
      {
          var httpResponseMessage = httpClient.GetAsync(url).Result;
          return httpResponseMessage.Content.ReadAsStringAsync().Result;
      }
      catch (Exception ex) { return ex; }
  }
  
  [Fact]
  public void either_example()
  {
  
      GetHtml("unknown url"); // Left InvalidOperationException
      GetHtml("https://www.google.com"); // Right <!doctype html...
  
      var result = GetHtml("https://www.google.com");
  
      result.Match(
              Left: ex => Console.WriteLine("an exception occured" + ex),
              Right: r => Console.WriteLine(r)
          );
  }
  ```

<br>

## Fold vs Reduce

- List.fold : ('State -> 'T -> 'State) -> 'State -> 'T -> 'T list -> 'State
- List.reduce : ('T->'T->'T) -> 'T list -> 'T
  ```cs
  [Fact]
  public void fold_vs_reduce()
  {
      //fold takes an explicit initial value for the accumulator
      //Can choose the result type
      var foldResult = List(1, 2, 3, 4, 5)
          .Map(x => x * 10)
          .Fold(0m, (x, s) => s + x); // 150m
  
      //reduce uses the first element of the input list as the initial accumulator value
      //Result type will be the one of the list
      var reduceResult = List(1, 2, 3, 4, 5)
          .Map(x => x * 10)
          .Reduce((x, s) => s + x); // 150
  }
  ```

<br><br>

# ğŸšœì¶”ê°€ë‚´ìš©

## TryOption

- Tryì˜ ì˜ˆì™¸ì²˜ë¦¬ ê¸°ëŠ¥ê³¼ Optionì˜ null ì²˜ë¦¬ ê¸°ëŠ¥ì´ í•©ì¹œ ë‚´ìš©ì…ë‹ˆë‹¤.
  ```cs
  public TryOption<string> GetEmail(long id)
  {
    return Try(() => GetById(id))
            .Map(person => person.Email)
            .ToTryOption();
  }

  public void SendEmail(long personId)
  {
    GetEmail(personId)
      .Match(email =>
      {
        emailService.SendWelcome(email);
        logger.LogSuccess($"Email sent for {personId}");
      },
      () => logger.LogSuccess($"Email not sent for {personId}"),
      exception => logger.LogSuccess($"Error for {personId} {exception}");
      )
  }
  ```
  
<br>


# í™œìš© ì˜ˆì‹œ
- ë‹¤ì¤‘ Null Check -> Optionì˜ Bind ê¸°ëŠ¥ í™œìš©í•˜ê¸°
- Before
  ```cs
  public string Register(long personId)
  {
    try
    {
      var person = personRepository.GetId(personId);
      if (person == null)
      {
        return null;
      }
      
      var account = twitterService.Register(person.Email, person.Name);
      if (account == null)
      {
        return null;
      }

      var token = twitterService.Authenticate(person.Email, person.Password);
      if (token == null)
      {
        return null;
      }

      var tweet = twitterService.Tweet(token, "Hello les cocos");

      personRepository.Update(personId, account.Id);
      logger.LogSuccess($"User {personID} registered");

      return tweet.Url;
    }
    catch (Exception ex)
    {
      logger.LogFailure($"Unable to register user : {personId} {ex.Message}");
      return null;
    }
  }
  ```
- After
  ```cs
        private TryAsync<Context> CreateContext(long personId)
        {
            return TryAsync(() => personRepository.GetById(personId))
                    .Map(person => new Context(person));
        }

        private TryAsync<Context> RegisterTwitter(Context context)
        {
            return TryAsync(() => twitterService.Register(context.Email, context.Name))
                    .Map(account => context.SetAccount(account));
        }

        private TryAsync<Context> Authenticate(Context context)
        {
            return TryAsync(() => twitterService.Authenticate(context.Email, context.Password))
                    .Map(token => context.SetToken(token));
        }

        private TryAsync<Context> Tweet(Context context)
        {
            return TryAsync(() => twitterService.Tweet(context.Token, "Hello les cocos"))
                    .Map(tweet => context.SetTweet(tweet));
        }

        private TryAsync<Context> UpdateParty(Context context)
        {
            return TryAsync(async () =>
            {
                await personRepository.Update(context.Id, context.AccountId);
                return context;
            });
        }

        public async Task<string> Register(long personId)
        {
            string result = string.Empty;
            await CreateContext(personId)
                    .Bind(RegisterTwitter)
                    .Bind(Authenticate)
                    .Bind(Tweet)
                    .Bind(UpdateParty)
                    .Match(
                    context =>
                    {
                        logger.LogSuccess($"User {personId} registered");
                        result = context.Url;
                    },
                    exception => logger.LogFailure($"Unable to register user : {personId} {exception.Message}"));

            return result;
        }
  ```


<br><br>


# ğŸšƒAsync


## OptionAsync
- Optionì˜ Async

## TryAsync
- Tryì˜ Async

## Aff, Eff

- Aff, Eff íƒ€ì…ì€ ì‚¬ì´ë“œ ì´í™íŠ¸ë¥¼ í¬ì°©í•˜ê¸° ìœ„í•´ ë§Œë“¤ì–´ì§„ ëª¨ë‚˜ë“œì…ë‹ˆë‹¤.
- í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì—ì„œ ì¤‘ìš”í•œ ì›ì¹™ ì¤‘ í•˜ë‚˜ì¸ ì‚¬ì´ë“œ ì´í™íŠ¸ê°€ ì—†ëŠ” ì½”ë“œ ì‘ì„±ì„ ë•ìŠµë‹ˆë‹¤.
```cs
using LanguageExt;
using static LanguageExt.Prelude;

Aff<int> Add(int x, int y) => Aff<int>(
    async () =>
    {
        await Task.Delay(1000); // Simulate some latency
        return x + y;
    });

var add = Add(10, 20);

var result = await add.Run(); // returns 30
Console.WriteLine($"Result = {result}"); // Result = Succ(30)
```
```cs
using LanguageExt;
using static LanguageExt.Prelude;

Eff<int> Add(int x, int y) => Eff<int>(
    () =>
    {
        return x + y;
    });

var add = Add(10, 20);

var result = add.Run(); // returns 30
```
```cs
public interface FileIO
{
    ValueTask<string[]> ReadAllLinesAsync(string path);
    ValueTask<Unit> WriteAllLinesAsync(string path, string[] lines);
}

public static class FileAff
{
    static readonly FileIO injected;
    
    public static Aff<Seq<string>> readAllLines(string path) =>
        Aff(async () => (await injected.ReadAllLinesAsync(path)).ToSeq());
    
    public static Aff<Unit> writeAllLines(string path, Seq<string> lines) =>
        Aff(async () =>
        {
            await injected.WriteAllLinesAsync(path, lines.ToArray());
            return unit;
        });
}
```

## Task í™•ì¥

<br><br>


<br><br>

# ğŸš²ì°¸ê³ ìë£Œ

- https://github.com/louthy/language-ext
- https://yoan-thirion.gitbook.io/knowledge-base/serious-games/how-to-create-a-game
- https://github.com/ythirion/fp-in-csharp-sandbox





<br><br>


---

<br><br>

# ì‹¬í™” ê¸°ìˆ 

- match
```cs
    Option<int> two = Some(2);
    Option<int> four = Some(4);
    Option<int> six = Some(6);
    Option<int> none = None;

    // This expression succeeds because all items to the right of 'in' are Some of int
    // and therefore it lands in the Some lambda.
    int r = match( from x in two
                   from y in four
                   from z in six
                   select x + y + z,
                   Some: v => v * 2,
                   None: () => 0 );     // r == 24

    // This expression bails out once it gets to the None, and therefore doesn't calculate x+y+z
    // and lands in the None lambda
    int r = match( from x in two
                   from y in four
                   from _ in none
                   from z in six
                   select x + y + z,
                   Some: v => v * 2,
                   None: () => 0 );     // r == 0
```
- Function ìˆœì„œ
```cs
var add = (int x, int y) => x + y; // Func<int, int, int>

var add = fun( (inr x, int y) => x + y );

var long = act( (int x) => Console.WriteLine(x) );
```

<br>

### ë¶ˆë³€ì˜ ë³€í™˜

- With
```cs
public class A
{
    public readonly X X;
    public readonly Y Y;

    public A(X x, Y y)
    {
        X = x;
        Y = y;
    }

    public A With(X X = null, Y Y = null) =>
        new A(
            X ?? this.X,
            Y ?? this.Y
        );
}
```
```cs
val = val.With(X: x);

val = val.With(Y: y);

val = val.With(X: x, Y: y);
```
- [With]
  - Nuget ì°¸ì¡° ì¶”ê°€ : LanguageExt.CodeGen (ìµœì¢… ë¹Œë“œì— ë¯¸í¬í•¨, ìˆœì „íˆ ì½”ë“œ ìƒì„± ëª©ì )
```cs
[With]
public partial class A
{
    public readonly X X;
    public readonly Y Y;

    public A(X x, Y y)
    {
        X = x;
        Y = y;
    }
}
```
- Lens í™œìš©í•œ getter, setter ìº¡ìŠí™”
```cs
[With]
public partial class Person
{
    public readonly string Name;
    public readonly string Surname;

    public Person(string name, string surname)
    {
        Name = name;
        Surname = surname;
    }

    public static Lens<Person, string> name =>
        Lens<Person, string>.New(
            Get: p => p.Name, // í•µì‹¬ë¶€ë¶„
            Set: x => p => p.With(Name: x));  // í•µì‹¬ë¶€ë¶„

    public static Lens<Person, string> surname =>
        Lens<Person, string>.New( 
            Get: p => p.Surname,  // í•µì‹¬ë¶€ë¶„
            Set: x => p => p.With(Surname: x));  // í•µì‹¬ë¶€ë¶„
}
```
```cs
var person = new Person("Joe", "Bloggs");

var name = Person.name.Get(person);
var person2 = Person.name.Set(name + "l", person);  // Joel Bloggs
var person3 = Person.name.Update(name => name + "l", person);  // Joel Bloggs
```
- [WithLens]
```cs
[WithLens]
public partial class Person : Record<Person>
{
    public readonly string Name;
    public readonly string Surname;
    public readonly Map<int, Appt> Appts;

    public Person(string name, string surname, Map<int, Appt> appts)
    {
        Name = name;
        Surname = surname;
        Appts = appts;
    }
}

[WithLens]
public partial class Appt : Record<Appt>
{
    public readonly int Id;
    public readonly DateTime StartDate;
    public readonly ApptState State;

    public Appt(int id, DateTime startDate, ApptState state)
    {
        Id = id;
        StartDate = startDate;
        State = state;
    }
}

public enum ApptState
{
    NotArrived,
    Arrived,
    DNA,
    Cancelled
}
```
```cs
// Generate a Person with three Appts in a Map
var person = new Person("Paul", "Louth", Map(
    (1, new Appt(1, DateTime.Parse("1/1/2010"), ApptState.NotArrived)),
    (2, new Appt(2, DateTime.Parse("2/1/2010"), ApptState.NotArrived)),
    (3, new Appt(3, DateTime.Parse("3/1/2010"), ApptState.NotArrived))));

// Local function for composing a new lens from 3 other lenses
Lens<Person, ApptState> setState(int id) => 
    lens(Person.appts, Map<int, Appt>.item(id), Appt.state);

// Transform
var person2 = setState(2).Set(ApptState.Arrived, person);
```
